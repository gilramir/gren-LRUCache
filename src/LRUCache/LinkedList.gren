module LRUCache.LinkedList exposing (..)

import Dict exposing (Dict)

type LinkedList comparable v =
    LinkedList
    { firstAndLast : Maybe { firstItem: comparable, lastItem: comparable }
    , nodes : Dict comparable (Link comparable v)
    }


type Link comparable v =
    Link
    { previous : Maybe comparable
    , next : Maybe comparable
    , dictValue : v
    }

toDict : LinkedList comparable v -> Dict comparable v
toDict (LinkedList { nodes }) =
    Dict.map (\comparable (Link {dictValue}) -> dictValue) nodes

emptyLinkedList : LinkedList comparable v
emptyLinkedList =
    LinkedList
        { firstAndLast = Nothing
        , nodes = Dict.empty
        }

pushFront : comparable -> v -> LinkedList comparable v -> LinkedList comparable v
pushFront newItem newDictValue list =
    let
        -- If a is already in the list then remove it
        (LinkedList {firstAndLast, nodes} as listToUse) =
            if has newItem list then
                (remove newItem list)
            else
                list
    in
        when firstAndLast is
            Nothing ->
                -- Nothing is in the list at all. Set this new item to the head, last and
                -- add an entry for it in the nodes map to denote it has no siblings.
                LinkedList
                    { firstAndLast = Just { firstItem = newItem, lastItem = newItem }
                    , nodes = Dict.set newItem (Link
                        { previous = Nothing
                        , next = Nothing
                        , dictValue = newDictValue
                        }) nodes
                    }

            Just { firstItem = firstItem, lastItem = lastItem } ->
                let
                    maybeFirstLink =
                        getLink firstItem listToUse

                    newLink =
                        (Link
                            { previous = Nothing
                            , next = Just firstItem
                            , dictValue = newDictValue
                            })
                in
                    when maybeFirstLink is
                        Nothing ->
                            -- This can't happen, as we know there is a
                            -- firstItem
                            list

                        Just originalFirstLink ->
                            LinkedList
                                { firstAndLast = Just { firstItem = newItem, lastItem = lastItem }
                                , nodes =
                                    nodes
                                        |> Dict.set newItem newLink
                                        |> Dict.set firstItem
                                        (Link
                                            { previous = Just newItem
                                            , next = linkNext originalFirstLink
                                            , dictValue = linkDictValue originalFirstLink
                                            })
                                }

getLink : comparable -> LinkedList comparable v -> Maybe (Link comparable v)
getLink item (LinkedList {nodes}) =
    Dict.get item nodes


linkDictValue : Link comparable v -> v
linkDictValue (Link { dictValue }) =
    dictValue


linkNext : Link comparable v -> Maybe comparable
linkNext (Link {next})  =
    next

linkPrevious : Link comparable v -> Maybe comparable
linkPrevious (Link {previous}) =
    previous


has : comparable -> LinkedList comparable v -> Bool
has item (LinkedList {nodes}) =
    Dict.member item nodes

remove : comparable -> LinkedList comparable v -> LinkedList comparable v
remove item (LinkedList {firstAndLast, nodes} as list) =
    when firstAndLast is
        Nothing ->
            list

        Just { firstItem = firstItem, lastItem = lastItem } ->
            let
                linkMaybe =
                    Dict.get item nodes
            in
                when linkMaybe is
                    Nothing ->
                        -- That key wasn't even in this list
                        list

                    Just link ->
                        -- The key is in the list
                        remove_link item link firstItem lastItem list

remove_link : comparable -> Link comparable v -> comparable -> comparable -> LinkedList comparable v -> LinkedList comparable v
remove_link item link firstItem lastItem (LinkedList {firstAndLast, nodes} as list) =
    when linkPrevious link is
        Nothing ->
            -- If there was no previous link to this item...
            when linkNext link is
                Nothing ->
                    -- AND no next link, it must have been the only thing in the list
                    LinkedList
                        { firstAndLast = Nothing
                        , nodes = Dict.empty
                        }

                Just nextLinkKey ->
                    let
                        maybeNextLink = getLink nextLinkKey list
                    in
                        when maybeNextLink is
                            Nothing ->
                                -- Impossible
                                list
                            Just nextLink ->
                                -- BUT it has a next, it must have been the head. Leave the last alone, set
                                -- that next link to the new head.
                                LinkedList
                                    { firstAndLast = Just { firstItem = nextLinkKey, lastItem = lastItem }
                                    , nodes =
                                        nodes
                                            |> Dict.remove item
                                            |> Dict.set nextLinkKey (Link
                                                { previous = Nothing
                                                , next = linkNext nextLink
                                                , dictValue = linkDictValue nextLink
                                                })
                                    }

        Just previousLinkKey ->
            -- If there is a previous link...
            when linkNext link is
                Nothing ->
                    -- AND there is no next, then this must be the last item
                    let
                        maybePreviousLink = getLink previousLinkKey list
                    in
                        when maybePreviousLink is
                            Nothing ->
                                -- Impossible
                                list
                            Just previousLink ->
                                let
                                    previousLinkDictValue = linkDictValue previousLink
                                in
                                    LinkedList
                                        { firstAndLast = Just { firstItem = firstItem, lastItem = previousLinkKey }
                                        , nodes =
                                            nodes
                                                |> Dict.set previousLinkKey (Link
                                                    { previous = linkPrevious previousLink
                                                    , next = Nothing
                                                    , dictValue = previousLinkDictValue
                                                    })
                                                |> Dict.remove item
                                        }

                Just nextLinkKey ->
                    let
                        maybeNextLink = getLink nextLinkKey list
                    in
                        when maybeNextLink is
                            Nothing ->
                                -- Impossible
                                list
                            Just nextLink ->
                                let
                                    nextLinkDictValue = linkDictValue nextLink
                                    maybePreviousLink = getLink previousLinkKey list
                                in
                                    when maybePreviousLink is
                                        Nothing ->
                                            -- Impossible
                                            list
                                        Just previousLink ->
                                            let
                                                previousLinkDictValue = linkDictValue previousLink
                                            in
                                                -- AND there is a next, then this item has two siblings and they need to point to each other.
                                                -- It must not have been the first or last item
                                                LinkedList
                                                    { firstAndLast = Just { firstItem = firstItem, lastItem = lastItem }
                                                    , nodes =
                                                        nodes
                                                            |> Dict.set previousLinkKey (Link
                                                                { previous = linkPrevious previousLink
                                                                , next = Just nextLinkKey
                                                                , dictValue = previousLinkDictValue
                                                                })
                                                            |> Dict.set nextLinkKey (Link
                                                                { previous = Just previousLinkKey
                                                                , next = linkNext nextLink
                                                                , dictValue = nextLinkDictValue
                                                                })
                                                            |> Dict.remove item
                                                    }

getLastKey : LinkedList comparable v -> Maybe comparable
getLastKey (LinkedList {firstAndLast}) =
    when firstAndLast is
        Nothing ->
            Nothing

        Just { firstItem = _ , lastItem = lastItem } ->
            Just lastItem

